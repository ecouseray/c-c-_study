#define _CRT_SECURE_NO_WARNINGS 
#include <stdio.h>

// ------------------------------------------------------------------------------------------------------------------

// 关键字 typedef 类型重命名关键字
// unsigned int 重命名为 uint_32

//typedef unsigned int uint_32;
//typedef struct Node 
//{
//	int data;
//	struct Node* next;
//}Node;
//int main()
//{
//	unsigned int a = 0;
//	uint_32 b = 0;
//	struct Node s1;
//	Node s2;
//	return 0;
//}

// 关键字 static 修饰变量
// 1. 修饰局部变量
// 2. 修饰全局变量
// 3. 修饰函数
//void test1()
//{
//	int a = 1;
//	a++;
//	printf("%d ", a);
//}
//void test2()
//{
//	static int a = 1;
//	a++;
//	printf("%d ", a);
//}
// 1. 修饰局部变量
// static 修饰局部变量的时候，局部变量出了作用域，不会销毁，
// 本质上 static 修饰局部变量的时候，是改变了局部变量的存储位置
// 内存上分区：栈区、堆区、静态区
// 栈区：局部变量...
// static 修饰变量 称为 静态变量，存放在静态区
// 影响了 变量的生命周期，使其生命周期边长，变得和程序的生命周期一样
// 静态变量，全局变量，一般在编译的时候就分配了空间，指派了地址
//int main()
//{
//	int i = 0;
//	while (i < 10)
//	{
//		test1();
//		test2();
//		i++;
//	}
//	return 0;
//}

// 2. 修饰全局变量
// 在另一个.c 源文件中 定义一个全局变量，在本.c源文件中使用，只需要extern 申明一下就行
// 但是全局变量被static 修饰后，extern 修饰后任然不可使用
// static 修饰全局变量，改变了全局变量的链接属性，全局变量本来是有外部链接属性，
// 被static 修饰后，将外部链接属性变为了内部连接属性，其他源文件就不能再说用到这个全局变量了

//static int a = 10;

// 3. 修饰函数
// 函数也是具有外部链接属性的，static 修饰函数的时候，函数也是不再具有外部链接属性

//static int add(int x, int y)
//{
//	return (x + y);
//}
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int z = add(a, b);
//
//	return 0;
//}

// ------------------------------------------------------------------------------------------------------------------

// register - 寄存器 关键字
// 计算机中的存储设备：磁盘（外存）、内存、高速缓存（cache）、寄存器(集成在CPU上)
// 越往右，空间越小，CPU 读写速度越快

//int main()
//{
//	// 寄存器变量
//	register int a = 10; // 建议：10放在寄存器里
//	return 0;
//}


// ------------------------------------------------------------------------------------------------------------------

// #define 定义常量和宏
//#define MAX 10
//#define ADD(x,y) ((x) + (y)) // 宏体
//// 宏是完成替换的
////     宏名 宏的参数，参数无类型
//int main()
//{
//	int a = 10;
//	int b = 20;
//	printf("%d\n", MAX);
//	printf("%d\n", ADD(a, b));
//	return 0;
//}

// ------------------------------------------------------------------------------------------------------------------

// 指针
// 内存：内存会划分为一个个的内存单元，每个内存单元都有一个编号，一个内存单元的大小是：一个字节
// 32位电脑生成地址：地址线 上通电 1/0 32根地址线：
// 00000000000000000000000000000000
// 00000000000000000000000000000001
// ...
// 11111111111111111111111111111111
// 2 ^ 32 次方 = 4294967296 个字节 = 4GB
// 所以 32 根地址线，管理的 内存空间大小 最大为 4GB

//int main()
//{
//	int a = 10;
//	// a 占 4个字节，首字节的地址，就是a的地址，拿到的是那个小的地址  eg: 01 02 03 04 , 01 就是 a 的地址
//	int* pa = &a;
//	// pa 就是指针变量
//	// %p 打印 地址
//	// 内存单元的编号 -》 地址 -》 地址也称为指针
//	// 存放指针（地址）的变量就是指针变量
//	// * 说明 p 是指针变量， int 说明 p指向的对象是 int 类型的
//	printf("%p\n", &a);
//	*p = 20;
//  // 解引用操作符，意思就是通过p中存放的地址，找到p所指向的对象， *p 就是 p 指向的对象
//	return 0;
//}


// 各种指针变量的大小

//int main()
//{
//	printf("%zu\n", sizeof(int*));
//	printf("%zu\n", sizeof(char*));
//	printf("%zu\n", sizeof(long*));
//	printf("%zu\n", sizeof(short*));
//	printf("%zu\n", sizeof(double*));
//	printf("%zu\n", sizeof(float*));
//
//	// 因为指针变量使用来，存储地址的，无论是什么类型的变量，他的地址都是4个字节或者8个字节（64位机器）
//	return 0;
//}

// ------------------------------------------------------------------------------------------------------------------

// 结构体 : 把单一类型组合在一起使用

//struct stu
//{
//	int age;
//	char name[15];
//	char sex[5];
//	// 结构体成员
//};
//
//struct book
//{
//	char ID[32];
//	char name[32];
//	double jiage;
//};
//
//int main()
//{
//	struct stu a = { 15, "张三", "男" };
//	printf("%d %s %s\n", a.age, a.name, a.sex);
//	// 结构体对象.成员名
//	struct stu* pa = &a;
//	printf("%d %s %s\n", (*pa).age, (*pa).name, (*pa).sex);
//	printf("%d %s %s\n", pa->age, pa->name, pa->sex);
//	return 0;
//}

// #define 不是关键字，是预处理指令

int main()
{
	int num1 = 0;
	int num2 = 0;
	scanf("%d %d", &num1, &num2);
	int num3 = num1 / num2;
	int num4 = num1 % num2;
	printf("%d %d\n", num3, num4);

	return 0;
}
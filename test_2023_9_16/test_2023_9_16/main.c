#define _CRT_SECURE_NO_WARNINGS 
#include <stdio.h>



// 表达式求值
// 操作符的优先级和结合性
// 有些表达式的操作数在求值的过程中需要转换为其他类型
// 
// 隐式类型转换
// C的整型算术运算总是至少以缺省整型类型的精度来进行的。
// 为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升。
// 
// 整形提升是按照变量的数据类型的符号位来提升的
// 
// //无符号整形提升，高位补0
// 
// 
// 
//int main()
//{
//	char a = -1;
//	// -1 是 整形
//	// 10000000 00000000 00000000 00000001
//	// 11111111 11111111 11111111 11111110
//	// 11111111 11111111 11111111 11111111
//	// char 类型中只能存下一个字节，截断后存入char类型所创建的空间
//	// 11111111
//	return 0;
//}

//int main()
//{
//	char a = 5;
//	// 00000000 00000000 00000000 00000101  5是一个整形，在char中存不下，截断后存入
//	// 00000101
//	char b = 126;
//	// 00000000 00000000 00000000 01111110
//	// 0111 1110
//	char c = a + b;
//	// 00000101 char 类型 不满足至少为整数类型，就要整形提升，按符号位提升
//	// 00000000 00000000 00000000 00000101 - 提升后
//	// 0111 1110
//	// 00000000 00000000 00000000 01111110 - 提升后
//	// 相加
//	// 00000000 00000000 00000000 10000011 - 相加后再存入 char
//	// 10000011
//	// 以整形类型输出的时候，c又不满足一个整形，会整形提升，按符号位提升
//	// 11111111 11111111 11111111 10000011 - 提升后 - （这是内存中提升后的样子，补码）
//	// 11111111 11111111 11111111 10000010
//	// 10000000 00000000 00000000 01111101
//	// -125
//	//
//	printf("%d\n", c);
//	return 0;
//}

//int main()
//{
//	char a = 0xb6;
//	short b = 0xb600;
//	int c = 0xb6000000;
//	if (a == 0xb6)
//		printf("a");
//	if (b == 0xb600)
//		printf("b");
//	if (c == 0xb6000000)
//		printf("c");
//	return 0;
//}
// 整形提升之后，只会输出 c  unsigned char 就可以全部输出，因为无符号数，整形提升补充的是0，是一样的


//int main()
//{
//	char c = 1;
//	printf("%u\n", sizeof(c));
//	printf("%u\n", sizeof(+c));// 因为有操作符，是一个表达式，所以要整形提升后再计算，所以会输出4
//	printf("%u\n", sizeof(-c));
//	return 0;
//}

// 如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则操作就无法进行。下面的层次体系称为寻常算术转换
// long double
// double
// float
// unsigned long int
// long int
// unsigned int
// int
// 由下向上转换


// 逗号操作符的优先级最低
// 优先级讨论的一定是相邻的操作符
// 优先级相同的时候，要看结合性
// 
// 是否控制求值顺序（之前学到的 && || 短路运算）
//

// 一些问题表达式
// a*b + c*d + e*f
// 
// 
// c + --c;  寄存器中什么时候将左边的 c 准备好 也会影响计算结果
// 
//

//int main()
//{
//	int i = 10;
//	i = i-- - --i * (i = -3) * i++ + ++i;
//	printf("i = %d\n", i);
//	return 0;
//}
// 出自《C与指针》

//int fun()
//{
//	static int count = 1;
//	return ++count;
//}
//int main()
//{
//	int answer;
//	answer = fun() - fun() * fun();
//	printf("%d\n", answer);//输出多少？
//	return 0;
//}
// 调用顺序未知，结果不同
//


// 青蛙跳台阶
// 
//int fib(int n)
//{
//	if (n <= 2)
//		return n;
//	else
//		return fib(n - 1) + fib(n - 2);
//}
//int main() 
//{
//	int n = 0;
//	scanf("%d", &n);
//
//	int m = fib(n);
//	printf("%d\n", m);
//	return 0;
//}

// 删除指定数组中的某元素
// 可以用两个数组
// 可以用两个指针 
//
//int main()
//{
//	int a = 0;
//	int arr[50] = { 0 };
//
//}



// 给定一个数组，求一个数组中的最大值与最小值之差
// 存下来再比
// 不存直接比


// 多个大小写字母转换
// 使用getchar()
// 不使用getchar()
// scanf()函数在读取失败的时候返回EOF
// islower() toupper     isupper  to isupper   isalpha
// scanf(" %c", &ch), %c之前加空格的的意义
// 跳过下一个字符之前所有的空白字符




// 变种水仙花数Lily Number
// 655 = 6 * 55 + 65 * 5

//#include <math.h>
//int main()
//{
//	int i = 0;
//	for (i = 10000; i <= 99999; i++)
//	{
//		int sum = 0;
//		int j = 0;
//		for (j = 1; j <= 4; j++)
//		{
//			int k = (int)pow(10, j);
//			sum += ( i / k ) * (i % k );
//		}
//		
//		if (sum == i)
//		{
//			printf("%d\n", i);
//		}
//	}
//	return 0;
//}
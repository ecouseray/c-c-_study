#define _CRT_SECURE_NO_WARNINGS 

#include <stdio.h>

// 指针
// 内存
// 内存如何管理
// 切割成内存单元 - 1byte（字节）
// 如何精确的找到某个内存单元呢？
// 编号
// 0x00000000
// 把内存单元的编号称为地址，也叫指针
// 
//


//int main()
//{
//	int a = 10;// a是整形变量，占用四个字节的内存空间
//	int* pa = &a; // p是一个指针变量，用来存放地址
//	// 指针变量 里面存放的是一个地址，通过这个地址，可以找对一个对应的内存单元
//
//	// sizeof 的返回值 是 unsigned int
//	// %zu
//	// 
//	// 这里有个问题，既然在固定的位数下的机器上，指针变量的空间都是一样的，那为什么不弄一个统一的指针变量呢？
//	//
//	return 0;
//}


// 这里有个问题，既然在固定的位数下的机器上，指针变量的空间都是一样的，那为什么不弄一个统一的指针变量呢？

// 指针类型
// 
//
//int main()
//{
//	int a = 0x11223344;
//	//int* p = &a;
//	//*p = 0;
//	//char* p = &a;
//	//*p = 0;
//	float* p = &a;
//	*p = 0;
//	printf("a = %x\n", a);
//
//	return 0;
//}
// 1.指针类型 决定了 解引用的 时候 访问的字节个数
// 
// 这里有个问题，既然在固定的位数下的机器上，指针变量的空间都是一样的，那为什么不弄一个统一的指针变量呢？
// 解引用的时候不同
// 
// 2.指针类型决定了指针+1或者-1的时候跳过多少个字节（步长是多少）
// 
// 类型其实是一种视角，访问内存时候的视角
// 
//
//

//int main()
//{
//	int a = 0x11223344;
//	int* pi = &a;
//	float* pf = &a;
//	*pi = 100;
//	*pf = 100;
//	printf("a = %x\n", a);
//
//	return 0;
//}
// 为什么int* 指针和 float* 指针不能通用呢？
// 在pi的角度来看,他所指向的空间存放的是一个整形类型的数据，而pf的角度来看，它所指向的空间存放的是一个单精度浮点型的数据。所以：
// 上面的一段代码，在调试的时候，可以观察到，存放到内存中的完全是2个值，有很大差别
// 虽然他们，的权限，对内存上+1 -1 访问的是一样的，但是，他们对内存的解读方式是完全不同的，所以不能混用 
//

// 野指针：指针指向的位置是不可知的，不明确的
//int* test()
//{
//	int a = 10;
//	return &a;
//}
//int main()
//{
//	int* p = test();
//	return 0;
//}
// 空间被释放，但任然能找到，也是野指针


//1. 指针初始化
//2. 小心指针越界
//3. 指针指向空间释放即使置NULL
//4. 避免返回局部变量的地址
//5. 指针使用之前检查有效性
//



//#define N_VALUES 5
//int main()
//{
//	float values[N_VALUES];
//	float* vp;
//	//指针+-整数；指针的关系运算
//	for (vp = &values[0]; vp < &values[N_VALUES];)
//	{
//		*vp++ = 0;
//	}
//}


// 指针 - 指针 的绝对值  等于 指针之间元素的个数

//int main()
//{
//	int arr[10] = { 0 };
//	int a = &arr[9];
//	int b = &arr[0];
//	int c = a - b;
//	printf("%d\n", c);
//	return 0;
//}
//int main()
//{
//	int arr[10] = { 0 };
//	printf("%d\n", &arr[9] - &arr[0]);
//	return 0;
//}

//for (vp = &values[N_VALUES]; vp > &values[0];)
//{
//	*--vp = 0;
//}

//for (vp = &values[N_VALUES - 1]; vp >= &values[0]; vp--)
//{
//	*vp = 0;
//}


// 允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。

//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9,0 };
//	int* p = arr; //指针存放数组首元素的地址
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	for (int i = 0; i < sz; i++)
//	{
//		printf("&arr[%d] = %p <====> p+%d = %p\n", i, &arr[i], i, p + i);
//	}
//	printf("\n");
//	for (int i = 0; i < sz; i++)
//	{
//		printf("&arr[%d] = %p <====> p+%d = %p\n", i, &arr[i], i, arr + i);
//	}
//	return 0;
//}


// 二级指针
// 当我们用一个函数修改另一个函数中的局部变量的时候
// 我们会给这个函数传被修改变量的局部变量的地址，我用在函数上用一级指针接收
// 当我们向函数传入一个指针变量的地址的时候，我们用二级直接接受
// 修改其中变量的值，修改的是，他所指向的地方，比如原来指向a我们让其指向b
// 也可以通过两次解引用操作，修改，原一级指针所指向空间中的值
//

//int main()
//{
//	int a = 10;
//	int* p = &a;
//	int** pp = &p; //第一颗星说明pp所指向的对象是int* 的，第二课星说明他是指针变量
//	return 0;
//}
// 二级指针使用来存放 一级指针变量 的地址的

//int main()
//{
//	int arr[10] = { 0 };
//	int (*ptr)[10] = &arr;
//	return 0;
//}

// 指针数组
//int main()
//{
//	int arr[10] = { 0, 1, 2, 3 };
//	int* ptr[10] = { &arr };
//	for (int i = 0; i < 4; i++)
//	{
//		printf("%d ", (*ptr)[i]);
//	}
//	printf("\n");
//	
//	return 0;
//}

int main()
{
	int arr1[4] = { 1,2,3,4 };
	int arr2[4] = { 2,3,4,5 };
	int arr3[4] = { 3,4,5,6 };
	
	int* ptr[3] = { arr1, arr2, arr3 };
	//创建一个ptr存放arr1...arr3 几个元素呢[3], 每个元素的类型呢？ int*


	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 4; j++)
		{
			printf("%d ", ptr[i][j]);
		}
	}

	return 0;
}
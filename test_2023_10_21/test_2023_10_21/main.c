int removeDuplicates(int* nums, int numsSize) {
   
}
/*
最朴实的解法：
	两个指针，prev 和 cur 两个指针比较内容，
	如果相同，让cur指针后，数组内所有元素向前移动一个，
	如果不同，两个指针向后移动

	如何考虑到用两个指针，因为这道题目与27题相比，不是数组元素和外部val比较，而是比较数组内
	两个相邻元素(有序数组)，所以我们考虑到用两个指针来控制，可能会方便一点。
*/
/*
朴实解法：
    两个指针，prev 和 cur 两个指针比较内容，如果相同向后++，如果不同将prev指针的内容拷贝到
    新的数组，拷贝结束之后，将新数组的内容拷贝给源数组

	这种解法，相比“最朴实的解法”来说，优点在于 如果数组内所有元素都相同，或者大部分元素相同的
	情况下(相同一次就要移动后面所有元素，顺序表PopFront)，以空间换时间，效率更高
*/
/*
高效解法：
	三个指针，原来的 prev 和	cur ，两个指针比较内容，如果相同向后++，如果不同将prev指针的内容
	拷贝到 dst 指向的位置，之后 dst++，重复。 
*/
// 共同问题，循环在 cur < numsSize 的情况下执行，最后一次比较之后，cur !< numsSize
// 但是任然有一个元素没有拷贝过去(即最后一个元素)，所以最后任然需要我们再处理一次

// 但是我们写好代码，执行之后发现，好像出问题了，内存问题。
// 当这个数组是一个空数组的时候，我们发现，我们的cur指针最开始就越界了
// 所以我们要处理一个这种 空数组的情况
// if (numsSize == 0) return 0;

/*

989.
int* addToArrayForm(int* num, int numSize, int k, int* returnSize){

}

取巧办法，用long long 类型保存nums数组，在 + k
但是发现，测试用例过不掉！ G！

此题用以：初探 大数相加


malloc 出来一块空间    多大？    整数 和 数组中数 位数高的 位数 + 1
1 <= num.length <= 10^4  1 <= k <= 10^4
取巧方式：
	上来只来malloc 6 个元素大小(在笔试的时候，尽可能快的通过、拿分)

用一个下标，表示数组最后一位，并且可以将整数也分离出来

但是这个代码其实还有一个问题，数组会越界
  99
1234
上面的数组就越界了 
*/
//#include <stdio.h>
//int main()
//{
//	int kTmp = 134;
//	int kSize = 1;
//	while (kTmp / 10)
//	{
//		++kSize;
//		kTmp /= 10;
//	}
//	printf("%d\n", kSize);
//}


/*

反转单链表

	取一个头插，取一个头插

	三个指针逆方向
		n1 n2 就可以逆了，但是会丢失3 所以再来一个n3指针
*/
